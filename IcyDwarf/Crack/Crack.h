/*
 * Crack.h
 *
 *  Created on: Apr 29, 2013
 *      Author: Marc Neveu (mneveu@asu.edu)
 *
 * 		Calculation of the depth and profile of cracking over time,
 * 		taking into account:
 * 		1. Grain thermal expansion/contraction mismatch
 * 		2. Pore water expansion
 * 		3. Hydration/dehydration
 * 		4. Dissolution/precipitation
 *
 * 		The thermal mismatch aspect (1) is adapted from Vance et al. (2007)
 * 		and was initially coded for Scilab in Dec. 2012.
 *
 * 		To work, this routine needs:
 *
 * 		1- Temperature vs. time (T(t)) and pressure vs. time (P(t))
 *   	   from a thermal evolution model, imported from a "kbo.dat" file
 *   	   that needs to be in the same folder as this file.
 *
 * 		2- Pre-built a(T,P) and integral tables that give the flaw size in
 *    	   a mineral grain yielding the maximum stress intensity K_I
 *   	   (see Fig. 1 of Vance et al. (2007)) at a given T and P.
 *   	   To build such a table, enable calculate_grain_aTP in
 *   	   IcyDwarfInput.txt.
 *
 *   	3- Pre-built tables of the thermal expansivity alpha and
 *   	   compressibility beta of pure water. These can be generated by
 *   	   enabling calculate_alpha_beta in IcyDwarfInput.txt.
 *
 *   	Assumes R and CHNOSZ are already open.
 *
 *   	Animated plots can be generated by enabling the plot_on option in
 *   	IcyDwarfInput.txt. As of 7/31/2013, the functionality is limited to
 *   	depth vs. time and W/R vs. time, with limited display and scaling
 *   	that don't work at all parameter ranges.
 *
 *      Ref.: Neveu et al. (2013) Cracking in Ceres' core as an oppor-
 * 		tunity for late hydrothermal activity. 44th LPSC, abstract 2216.
 */

#ifndef CRACK_H_
#define CRACK_H_

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <R.h>
#include <Rdefines.h>
#include <Rinternals.h>
#include <Rembedded.h>

#include "Crack_parameters.h"
#include "Crack_grain_aTP.h"
#include "Crack_water_CHNOSZ.h"

int Crack(int argc, char *argv[], char path[1024], int NR, int NT, float r_p, float timestep, float rho_p, thermalout **thoutput,
		int warnings, int msgout, int *crack_input, int *crack_species);

int Crack(int argc, char *argv[], char path[1024], int NR, int NT, float r_p, float timestep, float rho_p, thermalout **thoutput,
		int warnings, int msgout, int *crack_input, int *crack_species) {

	//-------------------------------------------------------------------
	//                 Declarations and initializations
	//-------------------------------------------------------------------

    int thermal_mismatch = 0;                                             // Grain thermal expansion/contraction mismatch effects
	int pore_water_expansion = 0;                                         // Pore water expansion effects
	int hydration_dehydration = 0;                                        // Rock hydration/dehydration effects
	int dissolution_precipitation = 0;                                    // Rock dissolution/precipitation effects

    int r = 0;
    int t = 0;
	int i = 0;
	int j = 0;
	float Crack_size_mem = 0.0;                                           // Memorize crack size between phenomena
	double Brittle_strength = 0.0;
	double Ductile_strength = 0.0;

	double **Pressure = (double**) malloc(NR*sizeof(double*));            // Pressure in Pa
	if (Pressure == NULL) printf("Crack: Not enough memory to create Pressure[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Pressure[r] = (double*) malloc(NT*sizeof(double));
		if (Pressure[r] == NULL) printf("Crack: Not enough memory to create Pressure[NR][NT]\n");
	}

	int *r_brittle_ductile = (int*) malloc(NT*sizeof(int));               // Brittle-ductile transition radius
	if (r_brittle_ductile == NULL) printf("Crack: Not enough memory to create r_brittle_ductile[NT]");

	float **Rock_strength = (float**) malloc(NR*sizeof(float*));          // Rock strength in Pa
	if (Rock_strength == NULL) printf("Crack: Not enough memory to create Rock_strength[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Rock_strength[r] = (float*) malloc(NT*sizeof(float));
		if (Rock_strength[r] == NULL) printf("Crack: Not enough memory to create Rock_strength[NR][NT]\n");
	}

	float **dTdt = (float**) malloc(NR*sizeof(float*));                   // Heating/cooling rate in K/Gyr
	if (dTdt == NULL) printf("Crack: Not enough memory to create dTdt[NR][NT]\n");
	for (r=0;r<NR;r++) {
		dTdt[r] = (float*) malloc(NT*sizeof(float));
		if (dTdt[r] == NULL) printf("Crack: Not enough memory to create dTdt[NR][NT]\n");
	}

	double **Crack = (double**) malloc(NR*sizeof(double*));               // Crack[NR][NT], cracked zone
	if (Crack == NULL) printf("Crack: Not enough memory to create Crack[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Crack[r] = (double*) malloc(NT*sizeof(double));
		if (Crack[r] == NULL) printf("Crack: Not enough memory to create Crack[NR][NT]\n");
	}

	float **Hydrated = (float**) malloc(NR*sizeof(float*));               // Hydrated[NR][NT], hydrated zone
	if (Hydrated == NULL) printf("Crack: Not enough memory to create Hydrated[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Hydrated[r] = (float*) malloc(NT*sizeof(float));
		if (Hydrated[r] == NULL) printf("Crack: Not enough memory to create hydrated[NR][NT]\n");
	}

	double **Crack_depth = (double**) malloc(NT*sizeof(double*));         // Crack_depth[NT][2]
	if (Crack_depth == NULL) printf("Crack: Not enough memory to create Crack_depth[NT][2]\n");
	for (t=0;t<NT;t++) {
		Crack_depth[t] = (double*) malloc(2*sizeof(double));
		if (Crack_depth[t] == NULL) printf("Crack: Not enough memory to create Crack_depth[NT][2]\n");
	}

	float *Mliq = (float*) malloc(NT*sizeof(float));                   // Mliq[NT]
	if (Mliq == NULL) printf("Crack: Not enough memory to create Mliq[NT]\n");

	float *Mcracked_rock = (float*) malloc(NT*sizeof(float));          // Mcracked_rock[NT]
	if (Mcracked_rock == NULL) printf("Crack: Not enough memory to create Mcracked_rock[NT]\n");

	double **WRratio = (double**) malloc(NT*sizeof(double*));          // WRratio[NT][2]
	if (WRratio == NULL) printf("Crack: Not enough memory to create WRratio[NT][2]\n");
	for (t=0;t<NT;t++) {
		WRratio[t] = (double*) malloc(2*sizeof(double));
		if (WRratio[t] == NULL) printf("Crack: Not enough memory to create WRratio[NT][2]\n");
	}

	// Thermal mismatch-specific variables
	int deltaT_int = 0;              // deltaT index in the aTP table
	int P_int = 0;                   // P index in the aTP table

	float **Tprime = (float**) malloc(NR*sizeof(float*));   // T' is the temperature at zero stress from thermal mismatch
	if (Tprime == NULL) printf("Crack: Not enough memory to create Tprime[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Tprime[r] = (float*) malloc(NT*sizeof(float));
		if (Tprime[r] == NULL) printf("Crack: Not enough memory to create Tprime[NR][NT]\n");
	}

	float **K_I = (float**) malloc(NR*sizeof(float*));       // K_I[NR][NT], cracked zone
	if (K_I == NULL) printf("Crack: Not enough memory to create K_I[NR][NT]\n");
	for (r=0;r<NR;r++) {
		K_I[r] = (float*) malloc(NT*sizeof(float));
		if (K_I[r] == NULL) printf("Crack: Not enough memory to create K_I[NR][NT]\n");
	}

	float **aTP = (float**) malloc((sizeaTP)*sizeof(float*));    // a[sizeaTP][sizeaTP], table of flaw sizes a
	                                                             // that maximize the stress K_I
	if (aTP == NULL) printf("aTP: Not enough memory to create a[sizeaTP][sizeaTP]\n");
	for (t=0;t<sizeaTP;t++) {
		aTP[t] = (float*) malloc((sizeaTP)*sizeof(float));
		if (aTP[t] == NULL) printf("Crack: Not enough memory to create a[sizeaTP][sizeaTP]\n");
	}

	float **integral = (float**) malloc(int_size*sizeof(float*)); // Initialize integral[int_size][2]
	if (integral == NULL) printf("Crack: Not enough memory to create integral[int_size][2]\n");
	for (i=0;i<int_size;i++) {
		integral[i] = (float*) malloc(2*sizeof(float));
		if (integral[i] == NULL) printf("Crack: Not enough memory to create integral[int_size][2]\n");
	}

	// Pore fluid heating-specific variables
	int tempk_int = 0;             // T index in the alpha and beta tables (P index is P_int, already declared)

	float **P_fluid = (float**) malloc(NR*sizeof(float*));       // P_fluid[NR][NT], effective pore fluid pressure
																 // in hydrothermal zone (scaled with pore geometry)
	if (P_fluid == NULL) printf("Crack: Not enough memory to create P_fluid[NR][NT]\n");
	for (r=0;r<NR;r++) {
		P_fluid[r] = (float*) malloc(NT*sizeof(float));
		if (P_fluid[r] == NULL) printf("Crack: Not enough memory to create P_fluid[NR][NT]\n");
	}

	float **alpha = (float**) malloc(sizeaTP*sizeof(float*));    // Thermal expansivity, K-1
	if (alpha == NULL) printf("Crack: Not enough memory to create alpha[sizeaTP][sizeaTP]\n");
	for (i=0;i<sizeaTP;i++) {
		alpha[i] = (float*) malloc(sizeaTP*sizeof(float));
		if (alpha[i] == NULL) printf("Crack: Not enough memory to create alpha[sizeaTP][sizeaTP]\n");
	}

	float **beta = (float**) malloc(sizeaTP*sizeof(float*));     // Compressibility, bar-1
	if (beta == NULL) printf("Crack: Not enough memory to create beta[sizeaTP][sizeaTP]\n");
	for (i=0;i<sizeaTP;i++) {
		beta[i] = (float*) malloc(sizeaTP*sizeof(float));
		if (beta[i] == NULL) printf("Crack: Not enough memory to create beta[sizeaTP][sizeaTP]\n");
	}

	// Rock hydration/dehydration-specific variables
	float Crack_size_hydr_old = 0.0;                              // Crack size before this step in m

	float **P_hydr = (float**) malloc(NR*sizeof(float*));         // P_hydr[NR][NT], pressure of hydration (stress)
	if (P_hydr == NULL) printf("Crack: Not enough memory to create P_hydr[NR][NT]\n");
	for (r=0;r<NR;r++) {
		P_hydr[r] = (float*) malloc(NT*sizeof(float));
		if (P_hydr[r] == NULL) printf("Crack: Not enough memory to create P_hydr[NR][NT]\n");
	}

	// Rock dissolution/precipitation-specific variables
	float **Crack_size = (float**) malloc(NR*sizeof(float*));     // Crack size (1/2 width in 1-D, radius in cylindrical 2-D)
	if (Crack_size == NULL) printf("Crack: Not enough memory to create Crack_size[NR][NT]\n");
	for (r=0;r<NR;r++) {
		Crack_size[r] = (float*) malloc(NT*sizeof(float));
		if (Crack_size[r] == NULL) printf("Crack: Not enough memory to create Crack_size[NR][NT]\n");
	}

	// index  species
	// -----  ------------------------------
	//   0    amorphous silica dissolution/precipitation
	//   1    serpentine (chrysotile) dissolution/precipitation
	//   2    carbonate (magnesite) dissolution/precipitation
	// -----  ------------------------------

	// No mallocs here, because we'll keep n_species small

	float R_diss[n_species_crack];                   // Dissolution/precipitation rate in mol m-3 s-1
	float Stoich_coef[n_species_crack];              // Stoichiometric coefficient of the dissolution product(s)
	float K_eq[n_species_crack];                     // Equilibrium constant, dimensionless
	float Ea_diss[n_species_crack];                  // Activation energy of dissolution/precipitation (J mol-1)
	float Molar_volume[n_species_crack];             // Molar volume in m3 mol-1

	// float CHNOSZ_T = 0.0;							 // CHNOSZ temperature, = T if T>minimum temp that CHNOSZ can handle, minimum temp otherwise
	float surface_volume_ratio = 0.0;                // Ratio of water-rock surface to fluid volume in m-1
	float d_crack_size = 0.0;                        // Net change in crack size in m
	float Crack_size_diss_old = 0.0;                 // Crack size before this step in m

	float **Act_prod = (float**) malloc(NR*sizeof(float*));         // Activity of the products, dimensionless or (mol m-3) if << salinity
	if (Act_prod == NULL) printf("Crack: Not enough memory to generate Act_prod[NR][n_species]\n");
	for (r=0;r<NR;r++) {
		Act_prod[r] = (float*) malloc(n_species_crack*sizeof(float));
		if (Act_prod[r] == NULL) printf("Crack: Not enough memory to generate Act_prod[NR][n_species]\n");
	}

	float **Act_prod_old = (float**) malloc(NR*sizeof(float*));     // Activity of the products at the previous step
	if (Act_prod_old == NULL) printf("Crack: Not enough memory to generate Act_prod_old[NR][n_species]\n");
	for (r=0;r<NR;r++) {
		Act_prod_old[r] = (float*) malloc(n_species_crack*sizeof(float));
		if (Act_prod_old[r] == NULL) printf("Crack: Not enough memory to generate Act_prod_old[NR][n_species]\n");
	}

	// Zero all the matrices
	for (t=0;t<NT;t++) {
		for (r=0;r<NR;r++) {
			Rock_strength[r][t] = 0.0;
			dTdt[r][t] = 0.0;
			Crack[r][t] = 0.0;
			Hydrated[r][t] = 0.0;
			Tprime[r][t] = 0.0;
			P_fluid[r][t] = 0.0;
			P_hydr[r][t] = 0.0;
			Crack_size[r][t] = 0.0;
		}
		Crack_depth[t][0] = 0.0, Crack_depth[t][1] = 0.0;
		Mliq[t] = 0.0;
		Mcracked_rock[t] = 0.0;
		WRratio[t][0] = 0.0, WRratio[t][1] = 0.0;
	}
	for (j=0;j<int_size;j++) {
		integral[j][0] = 0.0;
		integral[j][1] = 0.0;
	}
	for (i=0;i<sizeaTP;i++) {
		for (j=0;j<sizeaTP;j++) {
			aTP[i][j] = 0.0;
			alpha[i][j] = 0.0;
			beta[i][j] = 0.0;
		}
	}
	for (i=0;i<n_species_crack;i++) {
		R_diss[i] = 0.0;
		Ea_diss[i] = 0.0;
		K_eq[i] = 0.0;
		Molar_volume[i] = 0.0;
		for (r=0;r<NR;r++) {
			Act_prod[r][i] = 0.0;
			Act_prod_old[r][i] = 0.0;
		}
	}

	thermal_mismatch = crack_input[0];
	pore_water_expansion = crack_input[1];
	hydration_dehydration = crack_input[2];
	dissolution_precipitation = crack_input[3];

    //-------------------------------------------------------------------
    //                     Initialize physical tables
    //-------------------------------------------------------------------

	// Read the a(T,P) input file: table of a(deltaT,P) in the model of
	// Vance et al. (2007) so we don't have to calculate a(deltaT,P)
	// each time the routine is called. Use aTP() to generate this file.
	aTP = read_input (sizeaTP, sizeaTP, aTP, path, "Crack/aTP.dat");
	if (aTP[0][0] == 0) printf("Generate a table of a(T,P) using the aTP routine.\n");

	// Read the integral input file:
	// Geometry part of the integral in eqs. (3) and (4) of
	// Vance et al. (2007) for various a, to calculate the stress intensity K_I.
	integral = read_input (2, int_size, integral, path, "Crack/integral.dat");

	if (pore_water_expansion == 1) {
		// Open alpha and beta files
		alpha = read_input (sizeaTP, sizeaTP, alpha, path, "Crack/alpha.dat");
		beta = read_input (sizeaTP, sizeaTP, beta, path, "Crack/beta.dat");
	}
	if (dissolution_precipitation == 1) {
		// Silica: Equations (55) of Rimstidt and Barnes 1980 or (7-8) of Bolton et al. 1997 (porosity not included)
		// mol m-3 s-1 =no dim (scaled to 1 m-1)*mol L-1 s-1*nd*     no dim (=nd)
		Stoich_coef[0] = 1.0;

		// Serpentine: Exponent of Q/K remains 1 even though Q = a_silica^2 * a_Mg+2^3 / a_H+^6 = a_solutes^(5/6)
		// because many other stoichiometries are possible with serpentine.
		Stoich_coef[1] = 1.0;

		// Carbonate: Pokrovski and Schott 1999 suggest (Q/K)^4, which makes sense because Q = a_Mg+2^2 * a_CO3-2^2
		Stoich_coef[2] = 4.0;

		Ea_diss[0] = Ea_silica;                                    // Rimstidt and Barnes (1980)
		Ea_diss[1] = Ea_chrysotile;                                // Thomassin et al. (1977)
		Ea_diss[2] = Ea_magnesite;                                 // Valid for pH 5.4, but decreases with pH (Pokrovsky et al. 2009)

		Molar_volume[0] = Molar_volume_silica;                     // CHNOSZ - HDN+78
		Molar_volume[1] = Molar_volume_chrysotile;                 // CHNOSZ - HDN+78
		Molar_volume[2] = Molar_volume_magnesite;                  // CHNOSZ - HDN+78
	}
	Pressure = calculate_pressure(Pressure, NR, NT, thoutput);     // Pressure
	Mliq = calculate_mass_liquid (Mliq, NR, NT, thoutput);         // Mass of liquid

	//-------------------------------------------------------------------
	//                         Initial conditions
    //-------------------------------------------------------------------

	for (r=0;r<NR;r++) {
		Crack[r][0] = 0.0;                                              // No cracking
		Hydrated[r][0] = 1.0;                                           // Fully hydrated
	}

	//-------------------------------------------------------------------
	//                      Begin main loop over time
	//-------------------------------------------------------------------

	for (t=1;t<NT;t++) {                     // Need to start at t=1 because calling t-1 in several places
		for (r=0;r<NR;r++) {

			//-------------------------------------------------------------------
			//      Calculate rock strength in Pa in each layer over time
			//-------------------------------------------------------------------

			/* Find radius of brittle-ductile transition. In principle, the transition between brittle faulting and
			ductile flow depends on P, T, initial porosity, and rheological parameters such as grain size and strain
			rate (Wong and Baud 2012), as well as mineralogy (Kohlstedt et al. 1995). 	Here, we consider only P and T.

			We mix up brittle-ductile and brittle-plastic transitions, although we shouldn't (Kohlstedt et al. 1995).
			The transition is when the brittle strength equals the ductile strength.
			The brittle strength is given by a friction/low-P Byerlee type law: stress = mu*P
			mu = 0.3 to 0.5 (Escartin et al. 1997)
			The ductile strength is given by a flow law: epsilon = A*sigma^n*exp[(-Ea+P*V)/RT]
			AÅ10^-37, EaÅ8.9 kJ, VÅ3.2e-3 m3, nÅ3.8 (Hilairet et al. 2007, but for >1 GPa and >200¡C). Let's fix epsilon = 10^-15 s-1. */

			Brittle_strength = mu_Escartin*Pressure[r][t];
			Ductile_strength = pow(strain_rate,(1.0/n_flow_law)) * pow(A_flow_law,-1.0/n_flow_law)
							 * exp((Ea_flow_law + Pressure[r][t]*V_flow_law)/(n_flow_law*R_G*thoutput[r][t].tempk));
			if (Brittle_strength <= Ductile_strength) Rock_strength[r][t] = Brittle_strength;
			else Rock_strength[r][t] = Ductile_strength;
			// Debug if (t==456) printf("r=%d, Brittle strength=%g, ductile strength=%g, Rock strength=%g\n",r,Brittle_strength,Ductile_strength,Rock_strength[r][t]);

			//-------------------------------------------------------------------
			//  Calculate heating/cooling rate in K/Gyr in each layer over time
			//-------------------------------------------------------------------

			dTdt[r][t] = (thoutput[r][t].tempk - thoutput[r][t-1].tempk)/timestep;
			// dTdt[r][t] = -1.0e9;  // Arbitrary cooling rate of Vance et al. (2007)

			//-------------------------------------------------------------------
			//      Initialize crack and hydration in each layer over time
			//-------------------------------------------------------------------

			Hydrated[r][t] = Hydrated[r][t-1];                    // Start at final state of t-1
			Crack[r][t] = Crack[r][t-1];
			if (thoutput[r][t].tempk >= tempk_dehydration) Hydrated[r][t] = 0.0; // Dehydration above a threshold tempk

			//-------------------------------------------------------------------
			// Cracks open from thermal expansion / contraction mismatch
			// (Friedrich and Wong 1986, Vance et al. 2007)
			//-------------------------------------------------------------------

			if (thermal_mismatch == 1) {

				// Calculate T' in each layer over time, eq (2) of Vance et al. (2007)
				// T' is the temperature at zero stress from thermal mismatch

				if (dTdt[r][t] == 0.0) dTdt[r][t] = 1.0e-6; // To ensure continuity of T', otherwise T'=0
				Tprime[r][t] = Q/R_G/log(12.0*Omega*D0_deltab*E_Young/
								(sqrt(3.0)*n*k_B*L*L*L*fabs(dTdt[r][t])/Gyr2sec));

				// Calculate the stress intensity K_I in each layer over time,
				// eq (4) of Vance et al. (2007)
				K_I[r][t] = 0;
				if (Tprime[r][t] != 0) {

					// Look up the right value of a(T,P) to use in eq(4)
					deltaT_int = look_up (fabs(Tprime[r][t] - thoutput[r][t].tempk), 0.0, deltaT_step, sizeaTP, warnings);
					P_int = look_up (Pressure[r][t], 0.0, P_step, sizeaTP, warnings);
					int integralLine = (int) (aTP[deltaT_int][P_int]/a_min); // Index in the integral table

					// Calculate K_I
					K_I[r][t] = sqrt(2.0/(PI_greek*aTP[deltaT_int][P_int]))*integral[integralLine][1]*
							E_Young*Delta_alpha/(2.0*PI_greek*(1.0-nu_Poisson*nu_Poisson))*
							fabs(Tprime[r][t]-thoutput[r][t].tempk) -
							Pressure[r][t]*sqrt(PI_greek*aTP[deltaT_int][P_int]);
				}
			}

			//-------------------------------------------------------------------
			//               Cracks from hydration - dehydration
			//-------------------------------------------------------------------
			/* Dehydration would widen cracks. But at the dehydration temperature (800 K-ish for silicates)
			 we are far into the ductile regime (above 400 K-ish). So there is no point looking at cracks.

			 Calculate crack shrinking arising from rock swelling:
			 if epsilon is the displacement
			 epsilon = (l_hydr - l_rock) / l_rock = l_hydr/l_rock - 1
			 Assuming a cube of rock, V_hydr/V_rock = l_hydr^3 / l_rock^3 = rho_rock/rho_hydr

			 If cracks close completely, then stress can build up as in Hooke's law (if isotropy):
			 P_hydr = E_Young*epsilon
			 So P_hydr = E_Young*[(rho_rock/rho_hydr)^(1/3) - 1]
			 Actually, some pores remain open because of asperities.*/

			if (hydration_dehydration == 1) {

				// Hydrate only where there are cracks and where it's not already hydrated
				if (Crack[r][t] > 0.0 && Hydrated[r][t] == 0.0 && thoutput[r][t].tempk < tempk_dehydration) {

					// Initialize crack size
					Crack_size[r][t] = smallest_crack_size;  // I guess because smallest_crack_size is a #define, the code adds a residual 4.74e-11.
					                                         // No changes bigger than that residual will trigger a change in the cracking.
					if (Crack[r][t-1] > 0.0 && Crack_size[r][t-1] > 0.0) {
						Crack_size[r][t] = Crack_size[r][t-1];
					}
					Crack_size_hydr_old = Crack_size[r][t];
					d_crack_size = 0.0;
					if (thoutput[r][t].tempk < tempk_dehydration) { // Hydration
						d_crack_size = - 2.0*(pow((rhoRock/rhoHydr),0.333) - 1.0) * hydration_rate * timestep;
						if (Crack_size[r][t] + d_crack_size < 0.0) {
							P_hydr[r][t] = E_Young*(-d_crack_size-Crack_size[r][t])/(2.0*hydration_rate*timestep); // Residual rock swell builds up stresses
							Crack_size[r][t] = 0.0;          // Crack closes completely
						}
						else {
							P_hydr[r][t] = 0.0;
							Crack_size[r][t] = Crack_size[r][t] + d_crack_size;
						}
						// Debug if (t < 150) printf("t=%d, r=%d, Old crack size=%g, Crack_size=%g, d_crack_size=%g, P_hydr=%g\n",
						// t,r,Crack_size_hydr_old,Crack_size[r][t],d_crack_size,P_hydr[r][t]);
					}
					Crack_size_mem = Crack_size[r][t];
					Hydrated[r][t] = 1.0;
				}
			}

			//-------------------------------------------------------------------
			//             Expansion of pore water as it is heated
			//            (Norton 1984, Le Ravalec and GuŽguen 1994)
			//-------------------------------------------------------------------

			if (pore_water_expansion == 1) {

				if (Hydrated[r][t] > 0.0 && thoutput[r][t].tempk < tempk_dehydration) {

					// For now, let's say the pores are at lithostatic pressure (should not be too different from hydrostatic pressure,
					// as long there are only a few layers of cracks)
					// Also let pressure evolve with temperature.

					P_fluid[r][t] = 0.0;

					// Don't do calculations in undifferentiated or water areas, in dehydrated areas, or if no heating
					if (thoutput[r][t].mrock > thoutput[r][0].mrock
							&& Hydrated[r][t] > 0.0 && thoutput[r][t].tempk > thoutput[r][t-1].tempk) {

						// Look up the right value of alpha and beta, given P and T
						tempk_int = look_up (thoutput[r][t].tempk, (float) tempk_min, delta_tempk, sizeaTP, warnings);
						P_int = look_up (Pressure[r][t]/bar, (float) P_bar_min, delta_P_bar, sizeaTP, warnings);

						// Calculate fluid pressure, including geometric effects (Norton 1984)
						// P_fluid[r][t] = Pressure[r][t] + alpha_var/beta_var*bar*(thoutput[r][t].tempk-thoutput[r][t-1].tempk)*(1+2*aspect_ratio);
						P_fluid[r][t] = Pressure[r][t] + alpha[tempk_int][P_int]/beta[tempk_int][P_int]*bar*(thoutput[r][t].tempk-thoutput[r][t-1].tempk)*(1.0+2.0*aspect_ratio);
					}
				}
			}

			//-------------------------------------------------------------------
			//          Dissolution / precipitation (Bolton et al. 1997)
			//-------------------------------------------------------------------
			/* TODO For now, we take the activities of solutes to be like molalities (ideal solutions),
			 * even though that clearly doesn't work with our concentrated solutions.
			 * We take the activities of solids (rock and precipitates) and water to be 1.
			 */

			if (dissolution_precipitation == 1) {

				// Calculate dissolution/precipitation only where there are cracks
				if (Crack[r][t] > 0.0) {

					// Initialize crack size
					Crack_size[r][t] = smallest_crack_size;       // I guess because smallest_crack_size is a #define, the code adds a residual 4.74e-11.
					                                              // No changes bigger than that residual will trigger a change in the cracking.
					if (hydration_dehydration == 1) {
						if (Crack_size_mem > 0.0) { // Check crack size after hydration cracking calculations
							Crack_size[r][t] = Crack_size_mem;
						}
					}
					else {
						if (Crack[r][t-1] > 0.0 && Crack_size[r][t-1] > 0.0) {
							Crack_size[r][t] = Crack_size[r][t-1];
						}
					}
					Crack_size_diss_old = Crack_size[r][t];
					d_crack_size = 0.0;
					surface_volume_ratio = 2.0/Crack_size[r][t];  // Rimstidt and Barnes (1980) Fig. 6 for a cylinder/fracture

					// Use CHNOSZ to get reaction constants at given T and P
					/* TODO Get K_eq(T,P) dynamically from CHNOSZ instead. Somehow CHNOSZ gives an error for Mg+2 below 345 bar:
					   "Error in out$dgdT[idoit] <- dgdT : replacement has length zero"
					if (CHNOSZ_T < CHNOSZ_T_MIN) {
						if (warnings == 1) printf("Cryolava: T=%g K below minimum temp for CHNOSZ. Using T=%g K instead\n",CHNOSZ_T,CHNOSZ_T_MIN);
						CHNOSZ_T = CHNOSZ_T_MIN;
					}
					printf("t=%d, r=%d\n",t,r);
					K_eq[0] = pow(10.0,-	CHNOSZ_logK("amorphous silica", "cr", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
				   	   	   	   	   	   +    CHNOSZ_logK("SiO2", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95"));
					K_eq[1] = pow(10.0,-    CHNOSZ_logK("chrysotile", "cr", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   +2.0*CHNOSZ_logK("SiO2", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   +3.0*CHNOSZ_logK("Mg+2", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   +5.0*CHNOSZ_logK("H2O", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   -6.0*CHNOSZ_logK("H+", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95"));
					K_eq[2] = pow(10.0,-    CHNOSZ_logK("magnesite", "cr", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   +    CHNOSZ_logK("Mg+2", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95")
									   +    CHNOSZ_logK("CO3-2", "aq", CHNOSZ_T-Kelvin, Pressure[r][t]/bar, "IAPWS95"));
					printf("\t T=%g, K0=%g, K1=%g, K2=%g\n",CHNOSZ_T,log(K_eq[0])/log(10.0),log(K_eq[1])/log(10.0),log(K_eq[2])/log(10.0));
					*/
					// subcrt(c("SiO2","SiO2"),c(-1,1),c("cr","aq"),T=0,P=1000)
					K_eq[0] = pow(10.0,-2.96);
					// subcrt(c("chrysotile","SiO2","Mg+2","OH-","H2O"),c(-1,2,3,6,-1),c("cr","aq","aq","aq","liq"),T=0,P=1000)
					K_eq[1] = pow(10.0,-52);
					// subcrt(c("MgCO3","Mg+2","CO3-2"),c(-1,1,1),c("cr","aq","aq"),T=0,P=1000)
					K_eq[2] = pow(10.0,-6.727499);
					/* Debug
					 * if (r == 130 && t < 100) printf("t=%d, r=%d\n",t,r); // Debug
					 */
					for (i=0;i<n_species_crack;i++) {                                    // Include whichever species are needed
						if (crack_species[i] > 0) {
							Act_prod[r][i] = Act_prod_old[r][i];
							/* Debug
							 * if (r == 130 && t < 100) printf("\t Act_prod[%d]=%g, K_eq[%d]=%g\n",i,Act_prod[r][i]/1000,i,K_eq[i]);
							 */
							// (Act_prod in mol L-1 to scale with K, silica equation (i=0) assumes unit A/V).
							// The Arrhenius term is equivalent to a dissociation rate constant kdiss in mol m-2 s-1.
							R_diss[i] = surface_volume_ratio * exp(-Ea_diss[i]/(R_G*thoutput[r][t].tempk)) * 1.0 * (1-pow(Act_prod[r][i]/rhoH2ol,Stoich_coef[i])/K_eq[i]);
							/* Debug
							 * if (r == 130 && t < 100) printf("\t R_diss[%d]=%g with Arrhenius T scaling\n",i,R_diss[i]);
							 */
							// Update crack size (equation 61 of Rimstidt and Barnes 1980, ends up being independent of A/V)
							// and update Act_prod[r][i] (mol m-3)
							if (-Stoich_coef[i]*R_diss[i]*timestep*Gyr2sec > Act_prod[r][i]) {  // Everything precipitates
								/* Debug
								 * if (r == 130 && t < 100) printf("\t Every bit of species %d precipitates\n",i);
								 */
								// The change in size is everything that could precipitate (Q^nu), not everything that should have precipitated (Rdiss*timestep)
								d_crack_size = d_crack_size - Act_prod[r][i]*Molar_volume[i]/surface_volume_ratio; // Rimstidt and Barnes (1980) Eq 61
								/* Debug
								 * if (r == 130 && t < 100) printf("\t d_crack_size=%g\n",d_crack_size);
								 */
								Act_prod[r][i] = 0.0;                                        // Can't have negative conc.!
								/* Debug
								 * if (r == 130 && t < 100) printf("\t New Act_prod[%d]=%g\n",i,Act_prod[r][i]/1000);
								 */
							}
							else {
								/* Debug
								 * if (r== 130 && t < 100) printf("\t Some species %d in solution\n",i);
								 */
								d_crack_size = d_crack_size + R_diss[i]*timestep*Gyr2sec*Molar_volume[i]/surface_volume_ratio; // Rimstidt and Barnes (1980) Eq 61
								/* Debug
								 * if (r == 130 && t < 100) printf("\t d_crack_size=%g\n",d_crack_size);
								 */
								Act_prod[r][i] = Act_prod[r][i] + Stoich_coef[i]*R_diss[i]*timestep*Gyr2sec;
								/* Debug
								 * if (r == 130 && t < 100) printf("\t New Act_prod[%d]=%g\n",i,Act_prod[r][i]/1000);
								 */
							}
							Act_prod_old[r][i] = Act_prod[r][i];                          // Memorize the activity of products for the next timestep
						}
					}
					if (Crack_size[r][t] + d_crack_size > 0.0)                        // Update crack size
						Crack_size[r][t] = Crack_size[r][t] + d_crack_size;
					else {
						Crack_size[r][t] = 0.0;                                       // Pore clogged
						for (i=0;i<n_species_crack;i++) Act_prod_old[r][i] = 0.0;     // Reset old activity quotients
					}
					/* Debug
					 * if (r == 130 && t < 100) printf ("\t Crack size is now %.16f m\n",Crack_size[r][t]);
					 */
				}
				else {
					// If the crack is closed, clear the old activity quotients
					for (i=0;i<n_species_crack;i++) {
						Act_prod_old[r][i] = 0.0;
					}
				}
			}

			//-------------------------------------------------------------------
			//                      Determine cracked zones
			//-------------------------------------------------------------------

			// Cases where cracks appear
			if (thermal_mismatch == 1) {          // Mismatch stresses open cracks
				if (thoutput[r][t].mrock > thoutput[r][0].mrock
						&& (K_I[r][t] >= K_IC || Crack[r][t-1] == 1) && dTdt[r][t] < 0)
					Crack[r][t] = 1.0;            // Cooling cracks
				if (thoutput[r][t].mrock > thoutput[r][0].mrock
						&& (K_I[r][t] >= K_IC || Crack[r][t-1] == 2) && dTdt[r][t] >= 0)
					Crack[r][t] = 2.0;            // Heating cracks
			}
			if (hydration_dehydration == 1) {
				if (P_hydr[r][t] > Pressure[r][t] + Rock_strength[r][t])
					Crack[r][t] = 3.0;            // Compressive hydration cracks
			}
			if (pore_water_expansion == 1) {      // Open crack if the fluid pressure is high enough
				if (P_fluid[r][t] > Pressure[r][t] + Rock_strength[r][t])
					Crack[r][t] = 5.0;
			}
			if (dissolution_precipitation == 1) {
				if (Crack[r][t-1] > 0.0 && Crack_size[r][t] > Crack_size_diss_old)
					Crack[r][t] = 6.0;            // Dissolution widened crack
				if (Crack[r][t-1] > 0.0 && Crack_size[r][t] < Crack_size_diss_old)
					Crack[r][t] = 7.0;            // Precipitation shrunk crack
			}

			// Cases where cracks disappear
			if (thoutput[r][t].mrock <= thoutput[r][0].mrock)
				Crack[r][t] = 0.0;                // Trivial: not enough rock
			if (Rock_strength[r][t] < 0.99*Brittle_strength) // 0.99 to beat machine error
				Crack[r][t] = 0.0;                // Ductile zone
			if (hydration_dehydration == 1) {
				if (P_hydr[r][t] > 0.0 && P_hydr[r][t] <= Pressure[r][t] + Rock_strength[r][t]) {
					Crack[r][t] = -1.0;           // Crack closed because of hydration
					//printf("t=%d, r=%d, P_hydr[r][t]=%g\n",t,r,P_hydr[r][t]);
				}
			}
			if (dissolution_precipitation == 1) {
				if (Crack[r][t-1] > 0.0 && Crack_size[r][t] <= 0.0) {
					Crack[r][t] = -1.0;           // Crack closed after precipitation
				}
			}
		}   // End of main grid loop
		// Debug printf("t=%d, r_brittle_ductile = %d\n",t,r_brittle_ductile[t]);

		//-------------------------------------------------------------------
		//                   Determine cracking depth in km
		//-------------------------------------------------------------------

		Crack_depth[t][0] = t*timestep;   // T in Gyr
		Crack_depth[t][1] = (float) calculate_seafloor (thoutput, NR, NT, t) / NR*r_p;

		//-------------------------------------------------------------------
		// Determine the water to rock ratio W/R by mass in cracked layer
		//-------------------------------------------------------------------

		// Depends entirely on porosity! The W/R by volume is porosity.
		// Here, we say W/R = Mliq/Mcracked_rock.
		WRratio[t][0] = (double) t*timestep;                            // T in Gyr
		for (r=0;r<NR;r++) {
			if (Crack[r][t] > 0.0) {
				Mcracked_rock[t] = Mcracked_rock[t] + thoutput[r][t].mrock;
			}
		}
		if (Mcracked_rock[t] < 0.000001) WRratio[t][1] = 0.0;           // If Mcracked_rock is essentially 0, to avoid infinities
		else WRratio[t][1] = Mliq[t]/Mcracked_rock[t];

	}   // End of main time loop

	//-------------------------------------------------------------------
	//                           Write outputs
	//-------------------------------------------------------------------

	write_output(NT, NR, Crack, path, "Crack/Crack.txt");
	write_output(2, NT, Crack_depth, path, "Crack/Crack_depth.txt");
	write_output(2, NT, WRratio, path, "Crack/WR_ratio.txt");

	//-------------------------------------------------------------------
	//                Close input files and free mallocs
	//-------------------------------------------------------------------

	for (r=0;r<NR;r++) {
		free (Pressure[r]);
		free (Rock_strength[r]);
		free (dTdt[r]);
		free (Tprime[r]);
		free (K_I[r]);
		free (Crack[r]);
		free (Hydrated[r]);
		free (P_fluid[r]);
		free (P_hydr[r]);
		free (Crack_size[r]);
		free (Act_prod[r]);
		free (Act_prod_old[r]);
	}
	for (t=0;t<NT;t++) {
		free (Crack_depth[t]);
		free (WRratio[t]);
	}
	for (i=0;i<int_size;i++) {
		free (integral[i]); // Memory leak? but the code crashes if I loop over 2*int_size [anything above 1024], even though that was what was allocated.
	}
	for (i=0;i<sizeaTP;i++) {
		free (aTP[i]);
		free (alpha[i]);
		free (beta[i]);
	}
	free (Pressure);
	free (Rock_strength);
	free (dTdt);
	free (Crack);
	free (Hydrated);
	free (Crack_depth);
	free (Mliq);
	free (Mcracked_rock);
	free (WRratio);
	free (r_brittle_ductile);
	free (Tprime);          // Thermal mismatch-specific
	free (aTP);
	free (integral);
	free (K_I);
	free (P_fluid);         // Pore water expansion-specific
	free (alpha);
	free (beta);
	free (P_hydr);          // Hydration/dehydration-specific
	free (Crack_size);      // Dissolution/precipitation-specific
	free (Act_prod);
	free (Act_prod_old);

	printf("\n Outputs successfully generated in IcyDwarf/Crack/ directory:\n");
	printf("1. Cracked profile over time: Crack.txt\n");
	printf("2. Depth of cracking over time: Cracking_depth.txt\n");
	printf("3. Water/rock ratio in cracked zone over time: WR_ratio.txt\n\n");

	return 0;
}

#endif /* CRACK_H_ */
